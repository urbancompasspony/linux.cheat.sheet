#!/bin/bash

# Menu Simples de ConfiguraÃ§Ã£o de Rede

NETPLAN_FILE="/etc/netplan/50-cloud-init.yaml"

echo "ğŸŒ CONFIGURADOR SIMPLES DE REDE"
echo "================================"

# FunÃ§Ã£o 1: Mostrar status das interfaces
function show_interface_status() {
    echo ""
    echo "ğŸ“‹ STATUS DAS INTERFACES:"
    echo "â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”"
    echo "â”‚ Interface  â”‚ DescriÃ§Ã£o                               â”‚ Status  â”‚"
    echo "â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤"
    
    for interface in $(ls /sys/class/net/ | grep -E '^en' | sort); do
        # Status da interface
        status=$(cat /sys/class/net/$interface/operstate 2>/dev/null || echo "unknown")
        
        # Driver/DescriÃ§Ã£o
        driver=$(basename $(readlink /sys/class/net/$interface/device/driver) 2>/dev/null || echo "unknown")
        
        # Ãcone do status
        case $status in
            "up") status_icon="ğŸŸ¢ UP  " ;;
            "down") status_icon="ğŸ”´ DOWN" ;;
            *) status_icon="âšª $status" ;;
        esac
        
        printf "â”‚ %-10s â”‚ %-39s â”‚ %-7s â”‚\n" "$interface" "$driver" "$status_icon"
    done
    
    echo "â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜"
    echo ""
}

# FunÃ§Ã£o 2: Monitorar status em tempo real
function watch_interface_status() {
    echo ""
    echo "â±ï¸  MONITORAMENTO EM TEMPO REAL"
    echo "==============================="
    echo ""
    echo "ğŸ’¡ Conecte/desconecte cabos para ver mudanÃ§as instantÃ¢neas!"
    echo "   Pressione Ctrl+C para parar o monitoramento"
    echo ""
    echo "ğŸ”„ Iniciando monitoramento..."
    sleep 2
    
    # Loop de monitoramento
    while true; do
        # Limpa a tela
        clear
        
        # CabeÃ§alho
        echo "â±ï¸  MONITORAMENTO EM TEMPO REAL - $(date '+%H:%M:%S')"
        echo "=================================================="
        echo ""
        echo "ğŸ’¡ Pressione Ctrl+C para parar"
        echo ""
        
        # Tabela de status
        echo "ğŸ“‹ STATUS ATUAL DAS INTERFACES:"
        echo "â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”"
        echo "â”‚ Interface  â”‚ DescriÃ§Ã£o               â”‚ Status  â”‚ Cabo     â”‚Velocidadeâ”‚"
        echo "â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤"
        
        for interface in $(ls /sys/class/net/ | grep -E '^(en|lan|wan|dmz|mgmt)' | sort); do
            # Status da interface
            status=$(cat /sys/class/net/$interface/operstate 2>/dev/null || echo "unknown")
            
            # Driver/DescriÃ§Ã£o (nome mais curto para caber na tela)
            driver=$(basename $(readlink /sys/class/net/$interface/device/driver) 2>/dev/null || echo "unknown")
            driver=$(echo "$driver" | cut -c1-23)  # Limita a 23 caracteres
            
            # Status do cabo (carrier)
            carrier=$(cat /sys/class/net/$interface/carrier 2>/dev/null || echo "0")
            
            # Velocidade da conexÃ£o
            speed=""
            if [ "$carrier" = "1" ] && [ "$status" = "up" ]; then
                speed_val=$(cat /sys/class/net/$interface/speed 2>/dev/null || echo "-1")
                if [ "$speed_val" != "-1" ] && [ "$speed_val" != "" ]; then
                    speed="${speed_val}M"
                else
                    speed="N/A"
                fi
            else
                speed="-"
            fi
            
            # Ãcones do status
            case $status in
                "up") status_icon="ğŸŸ¢ UP  " ;;
                "down") status_icon="ğŸ”´ DOWN" ;;
                *) status_icon="âšª $status" ;;
            esac
            
            # Ãcones do cabo
            case $carrier in
                "1") cable_icon="ğŸ”— SIM  " ;;
                "0") cable_icon="âŒ NÃƒO  " ;;
                *) cable_icon="â“ N/A" ;;
            esac
            
            printf "â”‚ %-10s â”‚ %-23s â”‚ %-7s â”‚ %-8s â”‚ %-9s \n" "$interface" "$driver" "$status_icon" "$cable_icon" "$speed"
        done
        
        echo "â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜"
        
        # EstatÃ­sticas resumidas
        echo ""
        echo "ğŸ“Š RESUMO:"
        
        total_interfaces=$(ls /sys/class/net/ | grep -E '^(en|lan|wan|dmz|mgmt)' | wc -l)
        up_interfaces=$(ls /sys/class/net/ | grep -E '^(en|lan|wan|dmz|mgmt)' | while read iface; do cat /sys/class/net/$iface/operstate 2>/dev/null; done | grep -c "up")
        connected_cables=$(ls /sys/class/net/ | grep -E '^(en|lan|wan|dmz|mgmt)' | while read iface; do cat /sys/class/net/$iface/carrier 2>/dev/null; done | grep -c "1")
        
        echo "   ğŸ“ˆ Total de interfaces: $total_interfaces"
        echo "   ğŸŸ¢ Interfaces UP: $up_interfaces"
        echo "   ğŸ”— Cabos conectados: $connected_cables"
        
        # Aguarda 1 segundo antes da prÃ³xima atualizaÃ§Ã£o
        sleep 1
    done
}

# FunÃ§Ã£o 2: Monitorar status em tempo real
function watch_interface_status() {
    echo ""
    echo "â±ï¸  MONITORAMENTO EM TEMPO REAL"
    echo "==============================="
    echo ""
    echo "ğŸ’¡ Conecte/desconecte cabos para ver mudanÃ§as instantÃ¢neas!"
    echo "   Pressione Ctrl+C para parar o monitoramento"
    echo ""
    echo "ğŸ”„ Iniciando monitoramento..."
    sleep 2
    
    # Loop de monitoramento
    while true; do
        # Limpa a tela
        clear
        
        # CabeÃ§alho
        echo "â±ï¸  MONITORAMENTO EM TEMPO REAL - $(date '+%H:%M:%S')"
        echo "=================================================="
        echo ""
        echo "ğŸ’¡ Pressione Ctrl+C para parar"
        echo ""
        
        # Tabela de status
        echo "ğŸ“‹ STATUS ATUAL DAS INTERFACES:"
        echo "â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”"
        echo "â”‚ Interface  â”‚ DescriÃ§Ã£o               â”‚ Status  â”‚ Cabo     â”‚Velocidadeâ”‚"
        echo "â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤"
        
        for interface in $(ls /sys/class/net/ | grep -E '^(en|lan|wan|dmz|mgmt)' | sort); do
            # Status da interface
            status=$(cat /sys/class/net/$interface/operstate 2>/dev/null || echo "unknown")
            
            # Driver/DescriÃ§Ã£o (nome mais curto para caber na tela)
            driver=$(basename $(readlink /sys/class/net/$interface/device/driver) 2>/dev/null || echo "unknown")
            driver=$(echo "$driver" | cut -c1-23)  # Limita a 23 caracteres
            
            # Status do cabo (carrier)
            carrier=$(cat /sys/class/net/$interface/carrier 2>/dev/null || echo "0")
            
            # Velocidade da conexÃ£o
            speed=""
            if [ "$carrier" = "1" ] && [ "$status" = "up" ]; then
                speed_val=$(cat /sys/class/net/$interface/speed 2>/dev/null || echo "-1")
                if [ "$speed_val" != "-1" ] && [ "$speed_val" != "" ]; then
                    speed="${speed_val}M"
                else
                    speed="N/A"
                fi
            else
                speed="-"
            fi
            
            # Ãcones do status
            case $status in
                "up") status_icon="ğŸŸ¢ UP  " ;;
                "down") status_icon="ğŸ”´ DOWN" ;;
                *) status_icon="âšª $status" ;;
            esac
            
            # Ãcones do cabo
            case $carrier in
                "1") cable_icon="ğŸ”— SIM  " ;;
                "0") cable_icon="âŒ NÃƒO  " ;;
                *) cable_icon="â“ N/A" ;;
            esac
            
            printf "â”‚ %-10s â”‚ %-23s â”‚ %-7s â”‚ %-8s â”‚ %-9s \n" "$interface" "$driver" "$status_icon" "$cable_icon" "$speed"
        done
        
        echo "â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜"
        
        # EstatÃ­sticas resumidas
        echo ""
        echo "ğŸ“Š RESUMO:"
        
        total_interfaces=$(ls /sys/class/net/ | grep -E '^(en|lan|wan|dmz|mgmt)' | wc -l)
        up_interfaces=$(ls /sys/class/net/ | grep -E '^(en|lan|wan|dmz|mgmt)' | while read iface; do cat /sys/class/net/$iface/operstate 2>/dev/null; done | grep -c "up")
        connected_cables=$(ls /sys/class/net/ | grep -E '^(en|lan|wan|dmz|mgmt)' | while read iface; do cat /sys/class/net/$iface/carrier 2>/dev/null; done | grep -c "1")
        
        echo "   ğŸ“ˆ Total de interfaces: $total_interfaces"
        echo "   ğŸŸ¢ Interfaces UP: $up_interfaces"
        echo "   ğŸ”— Cabos conectados: $connected_cables"
        
        # Aguarda 1 segundo antes da prÃ³xima atualizaÃ§Ã£o
        sleep 1
    done
}

# FunÃ§Ã£o 3: Auto-configurar netplan (adiciona todas DOWN + mantÃ©m UP)
function auto_configure_netplan() {
    echo ""
    echo "ğŸ”§ AUTO-CONFIGURAÃ‡ÃƒO DO NETPLAN"
    echo "==============================="
    
    # Backup
    backup_file="/tmp/netplan_backup_$(date +%s).yaml"
    sudo cp "$NETPLAN_FILE" "$backup_file" 2>/dev/null
    echo "ğŸ“‹ Backup salvo em: $backup_file"
    
    # Detecta interfaces
    up_interfaces=()
    down_interfaces=()
    
    for interface in $(ls /sys/class/net/ | grep -E '^en'); do
        status=$(cat /sys/class/net/$interface/operstate 2>/dev/null || echo "unknown")
        if [ "$status" = "up" ]; then
            up_interfaces+=("$interface")
        elif [ "$status" = "down" ]; then
            down_interfaces+=("$interface")
        fi
    done
    
    echo "ğŸŸ¢ Interfaces UP encontradas: ${up_interfaces[*]:-nenhuma}"
    echo "ğŸ”´ Interfaces DOWN encontradas: ${down_interfaces[*]:-nenhuma}"
    echo ""
    
    # Gera nova configuraÃ§Ã£o
    echo "âš™ï¸  Gerando nova configuraÃ§Ã£o..."
    
    cat << EOF | sudo tee "$NETPLAN_FILE" > /dev/null
network:
  version: 2
  ethernets:
EOF
    
    # Adiciona interfaces UP (mantÃ©m configuraÃ§Ã£o)
    for interface in "${up_interfaces[@]}"; do
        echo "    $interface:" | sudo tee -a "$NETPLAN_FILE" > /dev/null
        echo "      dhcp4: true" | sudo tee -a "$NETPLAN_FILE" > /dev/null
        echo "   âœ… Mantida UP: $interface"
    done
    
    # Adiciona interfaces DOWN
    for interface in "${down_interfaces[@]}"; do
        echo "    $interface:" | sudo tee -a "$NETPLAN_FILE" > /dev/null
        echo "      dhcp4: true" | sudo tee -a "$NETPLAN_FILE" > /dev/null
        echo "   â• Adicionada DOWN: $interface"
    done
    
    echo ""
    echo "ğŸ“– NOVA CONFIGURAÃ‡ÃƒO GERADA:"
    echo "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"
    cat "$NETPLAN_FILE"
    echo "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"
    echo ""
    
    # Confirma aplicaÃ§Ã£o
    read -p "Aplicar configuraÃ§Ã£o? (y/n): " confirm
    if [ "$confirm" = "y" ] || [ "$confirm" = "Y" ]; then
        echo "ğŸš€ Aplicando configuraÃ§Ã£o..."
        if sudo netplan try --timeout=10; then
            echo "âœ… ConfiguraÃ§Ã£o aplicada com sucesso!"
        else
            echo "âŒ Erro! Restaurando backup..."
            sudo cp "$backup_file" "$NETPLAN_FILE"
            sudo netplan apply
            echo "âœ… Backup restaurado."
        fi
    else
        echo "âŒ AplicaÃ§Ã£o cancelada."
    fi
    echo ""
}

# FunÃ§Ã£o 4: Renomear interfaces
function rename_interfaces() {
    echo ""
    echo "âœï¸  RENOMEAR INTERFACES"
    echo "======================"
    echo ""
    
    # Lista interfaces disponÃ­veis
    interfaces=($(ls /sys/class/net/ | grep -E '^en' | sort))
    
    if [ ${#interfaces[@]} -eq 0 ]; then
        echo "âŒ Nenhuma interface ethernet encontrada!"
        return
    fi
    
    echo "ğŸ“‹ INTERFACES DISPONÃVEIS:"
    echo "â”Œâ”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”"
    echo "â”‚ NÂº  â”‚ Interface  â”‚ MAC Address       â”‚ Status  â”‚"
    echo "â”œâ”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤"
    
    for i in "${!interfaces[@]}"; do
        interface="${interfaces[$i]}"
        mac=$(cat /sys/class/net/$interface/address 2>/dev/null || echo "unknown")
        status=$(cat /sys/class/net/$interface/operstate 2>/dev/null || echo "unknown")
        
        case $status in
            "up") status_icon="ğŸŸ¢ UP" ;;
            "down") status_icon="ğŸ”´ DOWN" ;;
            *) status_icon="âšª $status" ;;
        esac
        
        printf "â”‚ %-3s â”‚ %-10s â”‚ %-17s â”‚ %-7s â”‚\n" "$((i+1))" "$interface" "$mac" "$status_icon"
    done
    
    echo "â””â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜"
    echo ""
    echo "0) Voltar ao menu principal"
    echo ""
    
    read -p "Escolha o nÃºmero da interface para renomear: " choice
    
    if [ "$choice" = "0" ]; then
        return
    fi
    
    if [ "$choice" -ge 1 ] && [ "$choice" -le "${#interfaces[@]}" ]; then
        selected_interface="${interfaces[$((choice-1))]}"
        current_mac=$(cat /sys/class/net/$selected_interface/address)
        
        echo ""
        echo "ğŸ¯ Interface selecionada: $selected_interface"
        echo "ğŸ·ï¸  MAC Address: $current_mac"
        echo ""
        echo "ğŸ’¡ SugestÃµes de nomes:"
        echo "   â€¢ lan0, lan1, lan2 (rede local)"
        echo "   â€¢ wan0, wan1 (internet)"
        echo "   â€¢ dmz0, dmz1 (DMZ)"
        echo "   â€¢ mgmt0 (gerenciamento)"
        echo ""
        
        read -p "Digite o novo nome: " new_name
        
        if [ -z "$new_name" ]; then
            echo "âŒ Nome nÃ£o pode estar vazio!"
            return
        fi
        
        # Valida nome
        if ! echo "$new_name" | grep -q '^[a-zA-Z][a-zA-Z0-9]*$'; then
            echo "âŒ Nome invÃ¡lido! Use apenas letras e nÃºmeros, comeÃ§ando com letra."
            return
        fi
        
        # Cria/atualiza regra udev
        rule_file="/etc/udev/rules.d/70-persistent-net.rules"
        
        # Remove regra antiga para este MAC (se existir)
        sudo sed -i "/ATTR{address}==\"$current_mac\"/d" "$rule_file" 2>/dev/null
        
        # Adiciona nova regra
        echo "SUBSYSTEM==\"net\", ACTION==\"add\", ATTR{address}==\"$current_mac\", NAME=\"$new_name\"" | sudo tee -a "$rule_file" > /dev/null
        
        echo ""
        echo "âœ… Regra criada com sucesso!"
        echo "   $selected_interface serÃ¡ renomeada para '$new_name' apÃ³s reinicializaÃ§Ã£o."
        echo ""
        echo "ğŸ”„ Para aplicar agora (sem reiniciar):"
        echo "   sudo udevadm control --reload-rules"
        echo "   sudo udevadm trigger"
        echo ""
        
        read -p "Aplicar regra agora? (y/n): " apply_now
        if [ "$apply_now" = "y" ] || [ "$apply_now" = "Y" ]; then
            sudo udevadm control --reload-rules
            sudo udevadm trigger
            echo "âœ… Regras aplicadas! A interface pode demorar alguns segundos para aparecer com o novo nome."
        fi
        
    else
        echo "âŒ OpÃ§Ã£o invÃ¡lida!"
    fi
    echo ""
}

# FunÃ§Ã£o 5: Fazer interface piscar (identificaÃ§Ã£o fÃ­sica)
function blink_interface() {
    echo ""
    echo "ğŸ’¡ IDENTIFICAÃ‡ÃƒO FÃSICA - PISCAR LED"
    echo "===================================="
    echo ""
    
    # Lista interfaces disponÃ­veis
    interfaces=($(ls /sys/class/net/ | grep -E '^(en|lan|wan|dmz|mgmt)' | sort))
    
    if [ ${#interfaces[@]} -eq 0 ]; then
        echo "âŒ Nenhuma interface encontrada!"
        return
    fi
    
    echo "ğŸ“‹ ESCOLHA UMA INTERFACE PARA PISCAR:"
    echo "â”Œâ”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”"
    echo "â”‚ NÂº  â”‚ Interface  â”‚ MAC Address       â”‚ Status  â”‚"
    echo "â”œâ”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤"
    
    for i in "${!interfaces[@]}"; do
        interface="${interfaces[$i]}"
        mac=$(cat /sys/class/net/$interface/address 2>/dev/null || echo "unknown")
        status=$(cat /sys/class/net/$interface/operstate 2>/dev/null || echo "unknown")
        
        case $status in
            "up") status_icon="ğŸŸ¢ UP" ;;
            "down") status_icon="ğŸ”´ DOWN" ;;
            *) status_icon="âšª $status" ;;
        esac
        
        printf "â”‚ %-3s â”‚ %-10s â”‚ %-17s â”‚ %-7s â”‚\n" "$((i+1))" "$interface" "$mac" "$status_icon"
    done
    
    echo "â””â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜"
    echo ""
    echo "0) Voltar ao menu principal"
    echo ""
    
    read -p "Digite o nÃºmero da interface: " choice
    
    if [ "$choice" = "0" ]; then
        return
    fi
    
    if [ "$choice" -ge 1 ] && [ "$choice" -le "${#interfaces[@]}" ]; then
        selected_interface="${interfaces[$((choice-1))]}"
        
        echo ""
        echo "ğŸ¯ Interface selecionada: $selected_interface"
        echo ""
        echo "ğŸ’¡ ATENÃ‡ÃƒO: Observe o LED da porta no servidor!"
        echo "    O LED vai piscar por 5 segundos..."
        echo ""
        echo "ğŸ”„ Iniciando piscar..."
        
        if sudo ethtool -p "$selected_interface" 5 2>/dev/null; then
            echo "âœ… LED piscou com sucesso!"
            echo "   Se vocÃª viu qual porta piscou, agora sabe onde fica a $selected_interface"
        else
            echo "âŒ Erro: NÃ£o foi possÃ­vel fazer o LED piscar."
            echo "   PossÃ­veis causas:"
            echo "   â€¢ Esta placa nÃ£o suporta piscar LED"
            echo "   â€¢ Driver nÃ£o suporta esta funÃ§Ã£o"
            echo "   â€¢ Interface estÃ¡ com problema"
        fi
        
        echo ""
        read -p "Testar outra interface? (y/n): " test_another
        if [ "$test_another" = "y" ] || [ "$test_another" = "Y" ]; then
            blink_interface
        fi
        
    else
        echo "âŒ OpÃ§Ã£o invÃ¡lida!"
    fi
    echo ""
}

# FunÃ§Ã£o 6: Atualizar netplan apÃ³s renomeaÃ§Ã£o
function update_netplan_after_rename() {
    echo ""
    echo "ğŸ”„ ATUALIZAR NETPLAN APÃ“S RENOMEAÃ‡ÃƒO"
    echo "==================================="
    echo ""
    
    # Mostra netplan atual
    echo "ğŸ“– CONFIGURAÃ‡ÃƒO ATUAL DO NETPLAN:"
    echo "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"
    cat "$NETPLAN_FILE"
    echo "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"
    echo ""
    
    # Mostra interfaces reais no sistema
    echo "ğŸ” INTERFACES REAIS NO SISTEMA:"
    show_interface_status
    
    # Detecta interfaces que existem no netplan mas nÃ£o no sistema
    echo "ğŸ” Verificando inconsistÃªncias..."
    
    # Extrai interfaces do netplan
    netplan_interfaces=($(grep -E '^\s+[a-zA-Z][^:]*:' "$NETPLAN_FILE" | sed 's/://g' | sed 's/^ *//' | sort))
    
    # Extrai interfaces reais do sistema
    real_interfaces=($(ls /sys/class/net/ | grep -E '^(en|lan|wan|dmz|mgmt)' | sort))
    
    echo ""
    echo "ğŸ“‹ INTERFACES NO NETPLAN: ${netplan_interfaces[*]:-nenhuma}"
    echo "ğŸ“‹ INTERFACES NO SISTEMA: ${real_interfaces[*]:-nenhuma}"
    echo ""
    
    # Verifica se hÃ¡ diferenÃ§as
    missing_in_system=()
    missing_in_netplan=()
    
    # Interfaces no netplan mas nÃ£o no sistema (possivelmente renomeadas)
    for np_iface in "${netplan_interfaces[@]}"; do
        found=false
        for real_iface in "${real_interfaces[@]}"; do
            if [ "$np_iface" = "$real_iface" ]; then
                found=true
                break
            fi
        done
        if [ "$found" = false ]; then
            missing_in_system+=("$np_iface")
        fi
    done
    
    # Interfaces no sistema mas nÃ£o no netplan
    for real_iface in "${real_interfaces[@]}"; do
        found=false
        for np_iface in "${netplan_interfaces[@]}"; do
            if [ "$real_iface" = "$np_iface" ]; then
                found=true
                break
            fi
        done
        if [ "$found" = false ]; then
            missing_in_netplan+=("$real_iface")
        fi
    done
    
    if [ ${#missing_in_system[@]} -eq 0 ] && [ ${#missing_in_netplan[@]} -eq 0 ]; then
        echo "âœ… Netplan estÃ¡ sincronizado com o sistema!"
        echo "   Nenhuma atualizaÃ§Ã£o necessÃ¡ria."
        return
    fi
    
    echo "ğŸ”„ INCONSISTÃŠNCIAS ENCONTRADAS:"
    if [ ${#missing_in_system[@]} -gt 0 ]; then
        echo "   âŒ No netplan mas nÃ£o existem no sistema: ${missing_in_system[*]}"
        echo "       (Possivelmente foram renomeadas)"
    fi
    if [ ${#missing_in_netplan[@]} -gt 0 ]; then
        echo "   â• No sistema mas nÃ£o estÃ£o no netplan: ${missing_in_netplan[*]}"
        echo "       (Precisam ser adicionadas)"
    fi
    echo ""
    
    read -p "Sincronizar netplan com o sistema atual? (y/n): " confirm
    if [ "$confirm" != "y" ] && [ "$confirm" != "Y" ]; then
        echo "âŒ SincronizaÃ§Ã£o cancelada."
        return
    fi
    
    # Backup
    backup_file="/tmp/netplan_backup_$(date +%s).yaml"
    sudo cp "$NETPLAN_FILE" "$backup_file"
    echo "ğŸ“‹ Backup salvo em: $backup_file"
    
    # Gera nova configuraÃ§Ã£o baseada nas interfaces reais
    echo "âš™ï¸  Gerando nova configuraÃ§Ã£o baseada no sistema atual..."
    
    cat << EOF | sudo tee "$NETPLAN_FILE" > /dev/null
network:
  version: 2
  ethernets:
EOF
    
    # Adiciona todas as interfaces reais com DHCP
    for interface in "${real_interfaces[@]}"; do
        echo "    $interface:" | sudo tee -a "$NETPLAN_FILE" > /dev/null
        echo "      dhcp4: true" | sudo tee -a "$NETPLAN_FILE" > /dev/null
        echo "   âœ… Adicionada: $interface"
    done
    
    echo ""
    echo "ğŸ“– NOVA CONFIGURAÃ‡ÃƒO SINCRONIZADA:"
    echo "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"
    cat "$NETPLAN_FILE"
    echo "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"
    echo ""
    
    # Confirma aplicaÃ§Ã£o
    read -p "Aplicar nova configuraÃ§Ã£o? (y/n): " apply_confirm
    if [ "$apply_confirm" = "y" ] || [ "$apply_confirm" = "Y" ]; then
        echo "ğŸš€ Aplicando configuraÃ§Ã£o..."
        if sudo netplan try --timeout=10; then
            echo "âœ… Netplan sincronizado e aplicado com sucesso!"
        else
            echo "âŒ Erro! Restaurando backup..."
            sudo cp "$backup_file" "$NETPLAN_FILE"
            sudo netplan apply
            echo "âœ… Backup restaurado."
        fi
    else
        echo "âŒ AplicaÃ§Ã£o cancelada."
    fi
    echo ""
}

function gerar_backup {
  sudo mkdir -p /srv/scripts/netplan
  sudo cp /etc/udev/rules.d/70-persistent-net.rules /srv/scripts/netplan/70-persistent-net.rules
  sudo cp "$NETPLAN_FILE" /srv/scripts/netplan/50-cloud-init.yaml
  sudo udevadm control --reload-rules
  sudo udevadm trigger
}

# Menu principal
# Menu principal
function main_menu() {
    while true; do
        echo ""
        echo "ğŸŒ MENU PRINCIPAL"
        echo "================"
        echo "1) Mostrar status das interfaces"
        echo "2) Monitorar interfaces em tempo real"
        echo "3) Auto-configurar netplan (adicionar todas DOWN)"
        echo "4) Renomear interfaces"
        echo "5) Piscar LED para identificar porta fÃ­sica"
        echo "6) Sincronizar netplan apÃ³s renomeaÃ§Ã£o"
	echo "7) Gerar Backup do Netplan"
        echo "0) Sair"
        echo ""
        read -p "Escolha uma opÃ§Ã£o: " option
        
        case "$option" in
            1) show_interface_status ;;
            2) watch_interface_status ;;
            3) auto_configure_netplan ;;
            4) rename_interfaces ;;
            5) blink_interface ;;
            6) update_netplan_after_rename ;;
	    7) gerar_backup ;;
            0) 
                echo "ğŸ‘‹ Saindo..."
                break 
                ;;
            *) 
                echo "âŒ OpÃ§Ã£o invÃ¡lida!" 
                ;;
        esac
        
        if [ "$option" != "0" ]; then
            read -p "Pressione ENTER para continuar..."
            clear
        fi
    done
}

# VerificaÃ§Ãµes iniciais
if [ "$EUID" -ne 0 ]; then
    echo "âŒ Este script precisa ser executado como root ou com sudo!"
    echo "   Execute: sudo $0"
    exit 1
fi

# Cria arquivo netplan se nÃ£o existir
if [ ! -f "$NETPLAN_FILE" ]; then
    echo "â„¹ï¸  Criando arquivo netplan bÃ¡sico..."
    mkdir -p "$(dirname "$NETPLAN_FILE")"
    cat << EOF > "$NETPLAN_FILE"
network:
  version: 2
  ethernets:
EOF
fi

# ExecuÃ§Ã£o
clear
main_menu
